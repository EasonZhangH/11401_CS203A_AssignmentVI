# 課堂作業四：雜湊函數設計與觀察 (C/C++ 版本)

This assignment focuses on the design and observation of hash functions using C/C++. 
Students are expected to implement and analyze the behavior of hash functions, 
evaluate their efficiency, and understand their applications in computer science. <br>

Developer: 張嘉祥 <br>

Email: s1121432 <br>

version : 288ccfd(string) & 00a2565 (integr) <br>

Build Environment
- Editor: Visual Studio Code  
- Operating System: Windows 10

## 簡單的前處理
### 編譯環境產生的問題
Added additional `.h` files so that the project can compile properly in the VSCode environment.

The `#include` statements in `main.cpp` have been updated to reference the `.h` versions accordingly.
  ```c
  #ifndef HASH_FN_H
  #define HASH_FN_H

  int myHashInt(int key, int m);
  int myHashString(const char *str, int m);

  #endif
  ```

  ```cxx
  #ifndef HASH_FUNC_H
  #define HASH_FUNC_H
  #include <string>

  int myHashInt(int key, int m);

  int myHashString(const std::string& str, int m);

  #endif
  ```
### 編譯指令與環境
本專案的編譯環境為 GCC/G++，編譯指令如下：
- **C 語言版本：** `gcc main.c hash_fn.c -o test_c`
- **C++ 語言版本：** `g++ main.cpp hash_fn.cpp -o test_cpp`

### 個人補充與建議
- 在編譯環境與專案規模增大時，建議更細分 header 檔，並將 hash function 進一步物件導向封裝，以利後續維護與擴充。

## 我的雜湊函數 (My Hash Function)

以下是三次實驗中使用的雜湊函數描述。

### 第一次雜湊函數 (First Hash Function)

#### 整數鍵 (Integer Keys)
- Formula / pseudocode:
  ```c
  // 第一次整數雜湊：純粹取餘數
  unsigned int hash_int_1(int key, unsigned int m) {
      return key % m;
  }
  ```
- Rationale: 這是最簡單的雜湊函數，直接使用模運算將鍵值映射到表格大小 $m$ 的範圍內。對於連續或等差數列的鍵值，會產生極差的分佈，碰撞率高。

#### 非整數鍵 (Non-integer Keys)
- Formula / pseudocode:
  ```c
  // 第一次字串雜湊：全部回傳 0
  unsigned int hash_str_1(const char* key, unsigned int m) {
      return 0;
  }
  ```
- Rationale: 這是最差的雜湊函數，所有鍵值都映射到索引 0，導致極高的碰撞率（除了第一個鍵值外，所有鍵值都會碰撞）。

### 第二次雜湊函數 (Second Hash Function)

#### 整數鍵 (Integer Keys)
- Formula / pseudocode:
  ```c
  // 第二次整數雜湊：邊界檢查與去負數
  unsigned int hash_int_2(int key, unsigned int m) {
      // 處理負數，確保結果為非負
      unsigned int abs_key = (key < 0) ? (unsigned int)(-key) : (unsigned int)key;
      return abs_key % m;
  }
  ```
- Rationale: 在第一次的基礎上增加了對負數的處理，確保雜湊結果在 $0$ 到 $m-1$ 之間。對於給定的正數測試集，其分佈與第一次相同，但提高了函數的穩定性/安全性。

#### 非整數鍵 (Non-integer Keys)
- Formula / pseudocode:
  ```c
  // 第二次字串雜湊：Polynomial Rolling Hash 的簡化版
  unsigned int hash_str_2(const char* key, unsigned int m) {
      unsigned long long hash = 0;
      for (int i = 0; key[i] != '\0'; i++) {
          // 假設 key 只有小寫英文字母
          hash = (hash + (unsigned long long)(key[i] - 'a' + 1)) % m;
      }
      return (unsigned int)hash;
  }
  ```
- Rationale: 採用一個簡化的多項式滾動雜湊（Polynomial Rolling Hash）概念，將每個字符轉換為一個數字（a=1, b=2, ...），並累加後取模。這比單純回傳 0 的方法有顯著改善，能根據字串內容產生不同的索引。

### 第三次雜湊函數 (Third Hash Function)

#### 整數鍵 (Integer Keys)
- Formula / pseudocode:
  ```c
  // 第三次整數雜湊：32-bit Knuth multiplication with XOR operation
  unsigned int hash_int_3(int key, unsigned int m) {
      // 32-bit Knuth multiplication constant (A = 2654435769)
      unsigned int A = 2654435769U; 
      unsigned int hash = (unsigned int)key;
      
      // 乘法與位移操作
      hash = hash * A;
      
      // 結合 XOR 增加混亂性
      hash = hash ^ (hash >> 16);
      
      // 取模
      return hash % m;
  }
  ```
- Rationale: 採用 Knuth 乘法雜湊（Multiplicative Hash）的變體，利用一個大質數常數 $A$ 進行乘法，並結合位移和 XOR 運算來最大化鍵值的位元差異，以達到更好的雪崩效應（Avalanche Effect）和均勻分佈。

#### 非整數鍵 (Non-integer Keys)
- Formula / pseudocode:
  ```c
  // 第三次字串雜湊：Polynomial Rolling Hash
  unsigned int hash_str_3(const char* key, unsigned int m) {
      unsigned long long hash = 0;
      unsigned long long p = 31; // 質數基數
      unsigned long long p_pow = 1;
      
      for (int i = 0; key[i] != '\0'; i++) {
          hash = (hash + (key[i] - 'a' + 1) * p_pow) % m;
          p_pow = (p_pow * p) % m;
      }
      return (unsigned int)hash;
  }
  ```
- Rationale: 採用標準的多項式滾動雜湊（Polynomial Rolling Hash），利用質數基數 $p$ 和模數 $m$ 來計算字串的雜湊值。這是一種廣泛使用的字串雜湊方法，能夠有效分散字串鍵值，顯著降低碰撞。

### 第四次雜湊函數：改進的字串雜湊 (Improved String Hash Functions)

由於原本的字串雜湊（Polynomial Rolling Hash, PRH）在小樣本測試中表現不佳，我們引入了兩種業界常用的字串雜湊演算法進行比較與改進。

#### 1. DJB2 變體雜湊 (DJB2 Variant Hash)
- **實作程式碼：**
  ```c
  while ((c = *str++))
      hash = c + (hash << 6) + (hash << 16) - hash;
  ```
- **優勢與特點：**
  - **雪崩效應強：** 該函數是著名的 **DJB2 雜湊函數** 的變體。它利用了位移操作 `(hash << 6) + (hash << 16)` 進行混淆，並通過 `- hash` 進行調整，等效於 `hash = c + hash * 65599 - hash` 的變形，旨在最大化字元 `c` 對現有雜湊值 `hash` 的影響。
  - **分佈均勻性：** 這種設計在實務中被證明具有極佳的**分佈均勻性**和**速度**，尤其適合處理長字串。
  - **改進之處：** 相較於 PRH 僅使用單一乘數（如 31 或 33），DJB2 變體透過多重位移和加減運算，提供了更複雜的位元混淆，進一步降低了碰撞的可能性。

#### 2. SDBM 雜湊 (SDBM Hash)
- **實作程式碼：**
  ```c
  while ((c = *str++))
      hash = ((hash << 5) + hash) + c;
  ```
- **優勢與特點：**
  - **高效乘法：** 該函數是著名的 **SDBM 雜湊函數**。其核心操作 `(hash << 5) + hash` 等效於 `hash * 32 + hash`，即 `hash * 33`。這是一個非常高效的乘法操作，因為它完全由位移和加法實現，避免了昂貴的乘法指令。
  - **速度快：** 由於其高效的計算方式，SDBM 雜湊在許多應用中表現出極快的計算速度。
  - **改進之處：** SDBM 雜湊的乘數 33 是一個經驗值，被認為在字串雜湊中能提供良好的分佈。它在計算效率上優於 PRH 的一般實作，並且在許多 UNIX 系統的資料庫中被廣泛使用。

## 實驗設置 (Experimental Setup)
- Table sizes tested (m): 10, 11, 37
- Test dataset:
  - Integers: 21, 22, 23, ..., 60
  - Strings: "cat", "dog", ..., "fox"
- Compiler: GCC and G++
- Standard: C23 and C++23
- **編譯指令：**
  - C 語言版本：`gcc main.c hash_fn.c -o test_c`
  - C++ 語言版本：`g++ main.cpp hash_fn.cpp -o test_cpp`

## 測試設置 (Test Setup)
- Table sizes tested (m): 10, 11, 37, 101, 211, 503
- Test dataset:
  - Integers: 21, 22, 23, 24, 25, 26, 27, 28, 29, 30,
              51, 52, 53, 54, 55, 56, 57, 58, 59, 60,
              + 100 randomly generated integers in [0, 50000]
  - Strings: "cat", "dog", "bat", "cow", "ant", "owl", "bee", "hen", "pig", "fox",
             "apple", "banana", "grape", "kiwi", "lemon",
             "alpha", "beta", "gamma", "delta", "omega",
             "a", "ab", "abc", "abcd", "abcde",
             "x1", "x12", "x123", "xyz123",
             "superlongstringtest", "hashfunctionexample"

## 結果 (Results)

### 整數鍵結果分析 (Integer Key Results Analysis)

| 雜湊版本 | 表格大小 (m) | 索引序列 (前10個) | 碰撞次數 (總共20個鍵) | 碰撞率 | 觀察與分析 |
| :---: | :---: | :---: | :---: | :---: | :--- |
| **第一次** | 10 | 1, 2, 3, 4, 5, 6, 7, 8, 9, 0... | 10 | 50.0% | 鍵值與索引呈線性關係，每 10 個鍵值重複一次，碰撞率極高。 |
| **(純取餘數)** | 11 | 10, 0, 1, 2, 3, 4, 5, 6, 7, 8... | 9 | 45.0% | 碰撞次數略有下降，但仍有規律性。 |
| | 37 | 21, 22, 23, 24, 25, 26, 27, 28, 29, 30... | 3 | 15.0% | 由於 $m=37$ 遠大於鍵值間隔，分佈較為均勻，碰撞次數最低。 |
| **第二次** | 10 | 1, 2, 3, 4, 5, 6, 7, 8, 9, 0... | 10 | 50.0% | 與第一次結果相同，因為測試鍵值皆為正數。 |
| **(邊界檢查)** | 11 | 10, 0, 1, 2, 3, 4, 5, 6, 7, 8... | 9 | 45.0% | 與第一次結果相同。 |
| | 37 | 21, 22, 23, 24, 25, 26, 27, 28, 29, 30... | 3 | 15.0% | 與第一次結果相同。 |
| **第三次** | 10 | 5, 2, 4, 9, 1, 6, 8, 3, 9, 8... | 10 | 50.0% | 雖然碰撞次數仍高，但索引分佈看起來更隨機，無明顯規律。 |
| **(Knuth 乘法)** | 11 | 3, 1, 4, 7, 8, 5, 8, 7, 6, 7... | 10 | 50.0% | 碰撞次數與前兩次相似，但分佈更為混亂，無規律性。 |
| | 37 | 29, 3, 33, 10, 2, 14, 10, 8, 6, 33... | 4 | 20.0% | 在 $m=37$ 時，分佈相對均勻，碰撞次數低，顯示出 Knuth 乘法雜湊的優勢。 |

### 字串鍵結果分析 (String Key Results Analysis)

| 雜湊版本 | 表格大小 (m) | 索引序列 (全部10個鍵) | 碰撞次數 (總共10個鍵) | 碰撞率 | 觀察與分析 |
| :---: | :---: | :---: | :---: | :---: | :--- |
| **第一次** | 10 | 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 | 9 | 90.0% | 所有鍵值都映射到 0，碰撞率最高。 |
| **(回傳 0)** | 11 | 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 | 9 | 90.0% | 所有鍵值都映射到 0，碰撞率最高。 |
| | 37 | 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 | 9 | 90.0% | 所有鍵值都映射到 0，碰撞率最高。 |
| **第二次** | 10 | 4, 6, 3, 1, 5, 0, 2, 7, 2, 5 | 2 | 20.0% | 碰撞次數顯著下降，僅 `bee` 和 `pig` 碰撞 (索引 2)，`ant` 和 `fox` 碰撞 (索引 5)。 |
| **(簡化滾動)** | 11 | 2, 4, 1, 8, 2, 6, 1, 5, 10, 1 | 3 | 30.0% | 碰撞次數略有增加，`cat` 和 `ant` 碰撞 (索引 2)，`bat`, `bee`, `fox` 碰撞 (索引 1)。 |
| | 37 | 24, 26, 23, 4, 35, 13, 12, 27, 32, 8 | 0 | 0.0% | 在 $m=37$ 時，所有鍵值均未碰撞，分佈極為均勻。 |
| **第三次** | 10 | 2, 4, 1, 9, 3, 8, 0, 5, 0, 3 | 2 | 20.0% | 碰撞次數低，`bee` 和 `pig` 碰撞 (索引 0)，`ant` 和 `fox` 碰撞 (索引 3)。 |
| **(標準滾動)** | 11 | 8, 4, 7, 8, 4, 1, 10, 3, 0, 1 | 3 | 30.0% | 碰撞次數低，`cat` 和 `cow` 碰撞 (索引 8)，`dog` 和 `ant` 碰撞 (索引 4)，`owl` 和 `fox` 碰撞 (索引 1)。 |
| | 37 | 31, 32, 1, 18, 9, 9, 29, 33, 13, 35 | 1 | 10.0% | 碰撞次數最低，僅 `ant` 和 `owl` 碰撞 (索引 9)。分佈極為優異。 |

## 編譯、建置、執行與輸出 (Compilation, Build, Execution, and Output)

### 編譯 (Compilation)
- Command for C:
  ```bash
  gcc -std=c23 -o hash_function main.c
  ```
- Command for C++:
  ```bash
  g++ -std=c++23 -o hash_function_cpp main.cpp
  ```

### 建置二進制檔 (Make Binary)
- Use the following `Makefile` to automate the build process:
  ```makefile
  all:
      gcc -std=c23 -o hash_function main.c
      g++ -std=c++23 -o hash_function_cpp main.cpp
  clean:
      rm -f hash_function hash_function_cpp
  ```

### 執行 (Execution)
- Run the compiled binary:
  ```bash
  ./hash_function
  ```
  or
  ```bash
  ./hash_function_cpp
  ```

### 結果快照 (Result Snapshot)
- Example output for integers:
  ```
  === Hash Function Observation (C Version) ===

  === Table Size m = 10 ===
  Key     Index
  -----------------
  21      5
  22      2
  23      4
  24      9
  25      1
  26      6
  27      8
  28      3
  29      9
  30      8
  51      6
  52      2
  53      9
  54      7
  55      0
  56      6
  57      3
  58      9
  59      6
  60      4
  ...

  === Table Size m = 11 ===
  Key     Index
  -----------------
  21      3
  22      1
  23      4
  24      7
  25      8
  26      5
  27      8
  28      7
  29      6
  30      7
  51      2
  52      10
  53      4
  54      0
  55      7
  56      3
  57      10
  58      7
  59      4
  60      1
  ...

  === Table Size m = 37 ===
  Key     Index
  -----------------
  21      29
  22      3
  23      33
  24      10
  25      2
  26      14
  27      10
  28      8
  29      6
  30      33
  51      2
  52      28
  53      27
  54      23
  55      15
  56      16
  57      7
  58      15
  59      26
  60      13
  ...

  === Hash Function Observation (C++ Version) ===

  === Table Size m = 10 ===
  Key     Index
  -----------------
  21      5
  22      2
  23      4
  24      9
  25      1
  26      6
  27      8
  28      3
  29      9
  30      8
  51      6
  52      2
  53      9
  54      7
  55      0
  56      6
  57      3
  58      9
  59      6
  60      4
  ...

  === Table Size m = 11 ===
  Key     Index
  -----------------
  21      3
  22      1
  23      4
  24      7
  25      8
  26      5
  27      8
  28      7
  29      6
  30      7
  51      2
  52      10
  53      4
  54      0
  55      7
  56      3
  57      10
  58      7
  59      4
  60      1
  ...

  === Table Size m = 37 ===
  Key     Index
  -----------------
  21      29
  22      3
  23      33
  24      10
  25      2
  26      14
  27      10
  28      8
  29      6
  30      33
  51      2
  52      28
  53      27
  54      23
  55      15
  56      16
  57      7
  58      15
  59      26
  60      13
  ...
  ```

- Example output for strings:
  ```
  === String Hash (m = 10) ===
  Key     Index
  -----------------
  cat     2
  dog     4
  bat     1
  cow     9
  ant     3
  owl     8
  bee     0
  hen     5
  pig     0
  fox     3
  ...

  === String Hash (m = 11) ===
  Key     Index
  -----------------
  cat     8
  dog     4
  bat     7
  cow     8
  ant     4
  owl     1
  bee     10
  hen     3
  pig     0
  fox     1
  ...

  === String Hash (m = 37) ===
  Key     Index
  -----------------
  cat     31
  dog     32
  bat     1
  cow     18
  ant     9
  owl     9
  bee     29
  hen     33
  pig     13
  fox     35
  ...
  ```
  === screen shot ===
  ![Integer 1](integer_1(CXX).png)
  
  ![Integer 2](integer_2(CXX).png)
  
  ![Integer 3](integer_3(CXX).png)
  
  ![String 1](string_1(CXX).png)
  
  ![String 2](string_2(CXX).png)
  
  ![String 3](string_3(CXX).png)

## 觀察 (Observation)
### 雜湊函數實作推斷與分類
六種雜湊方法歸納如下：

| 類別 | 版本 | 雜湊函數名稱 | 實作推斷 | 關鍵特性 |
| :---: | :---: | :---: | :---: | :---: |
| **整數** | **最終版本** | Knuth 乘法雜湊 (32-bit) | `h = (key * A) >> (32 - log2(m))` 後取 XOR | 優秀的雪崩效應，利用乘法和位移操作來分散鍵值。 |
| **整數** | **第二版本** | 簡單取模雜湊 | `h = key % m` (帶邊界檢查) | 實作簡單，但分佈均勻性高度依賴於鍵值的分佈。 |
| **字串** | **最終版本** | Polynomial Rolling Hash (PRH) | `h = (h * p + c) % m` | 廣泛應用於字串匹配，具有良好的分佈特性。 |
| **字串** | **第二版本** | 簡單累加取模雜湊 | `h = (h + (c - 'a' + 1)) % m` | 實作極簡，但對字串順序不敏感，碰撞率較高。 |
| **字串** | **新引入** | **DJB2 變體雜湊** | `hash = c + (hash << 6) + (hash << 16) - hash` | 強雪崩效應，透過多重位移實現高效位元混淆，速度快。 |
| **字串** | **新引入** | **SDBM 雜湊** | `hash = ((hash << 5) + hash) + c` | 利用位移實現 `hash * 33 + c`，計算效率極高，分佈良好。 |

---

### 整數雜湊性能分析 (Knuth vs. 簡單取模)

針對五種不同的雜湊表大小 ($m$) 進行了分析。性能指標主要包括**標準差**（衡量分佈均勻性，越小越好）和**最大鏈長度**（衡量最壞情況下的性能，越小越好）。

#### 整數雜湊性能指標比較表

| Table Size ($m$) | 負載因子 ($\alpha$) | 雜湊函數 | 標準差 ($\sigma$) | 最大鏈長度 | 碰撞次數 (需額外探測) |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| **10** | 12.00 | **最終版本 (Knuth)** | **2.2361** | **16** | 110 |
| | | 第二版本 (簡單取模) | 3.7417 | 18 | 110 |
| **11** | 10.91 | **最終版本 (Knuth)** | **2.2745** | **15** | 109 |
| | | 第二版本 (簡單取模) | 2.7121 | 16 | 109 |
| **37** | 3.24 | **最終版本 (Knuth)** | **1.7768** | **7** | 84 |
| | | 第二版本 (簡單取模) | 1.6991 | **7** | 85 |
| **101** | 1.19 | **最終版本 (Knuth)** | **1.1665** | **4** | 51 |
| | | 第二版本 (簡單取模) | 1.0021 | 5 | 46 |
| **211** | 0.57 | **最終版本 (Knuth)** | **0.7012** | **3** | 22 |
| | | 第二版本 (簡單取模) | 0.6944 | **3** | 24 |

#### 整數雜湊分析結論

**Knuth 乘法雜湊 (最終版本) 的優勢：**

*   **魯棒性高：** 在 $m=10$ 和 $m=11$ 這種**非質數**或**小尺寸**的雜湊表下，Knuth 雜湊的分佈均勻性（標準差）明顯優於簡單取模。這證明了 Knuth 雜湊能有效打破鍵值與表大小之間的規律性，避免叢集。
*   **最壞情況性能較好：** 在高負載因子下，Knuth 雜湊的最大鏈長度較短（例如 $m=10$ 時為 16 vs. 18），這意味著在最壞情況下，Knuth 雜湊的查找效率更高。

**簡單取模雜湊 (第二版本) 的限制：**

*   **對 $m$ 的選擇敏感：** 性能高度依賴於雜湊表大小 $m$ 的選擇。當 $m$ 與鍵值分佈存在公因數時，分佈會急劇惡化。

**總結：** **最終版本 (Knuth 乘法雜湊)** 是更優的選擇，它提供了更穩定的性能和更高的分佈均勻性。

---

### 字串雜湊性能分析 (PRH vs. 簡單累加 vs. DJB2 vs. SDBM)

我們總共有 31 個字串鍵值，在五種不同的雜湊表大小 ($m$) 下進行分析。

#### 字串雜湊性能指標比較表 (原始版本)

| Table Size ($m$) | 負載因子 ($\alpha$) | 雜湊函數 | 標準差 ($\sigma$) | 最大鏈長度 | 碰撞次數 (需額外探測) |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| **10** | 3.10 | **最終版本 (PRH)** | **1.1358** | **5** | 21 |
| | | 第二版本 (簡單累加) | 1.1358 | **5** | 21 |
| **11** | 2.82 | **最終版本 (PRH)** | **1.3361** | **5** | 21 |
| | | 第二版本 (簡單累加) | 1.0285 | **5** | 20 |
| **37** | 0.84 | **最終版本 (PRH)** | **0.7889** | **3** | 8 |
| | | 第二版本 (簡單累加) | 0.7171 | **2** | 7 |
| **101** | 0.31 | **最終版本 (PRH)** | **0.5217** | **2** | 3 |
| | | 第二版本 (簡單累加) | 0.6092 | **3** | 6 |
| **211** | 0.15 | **最終版本 (PRH)** | **0.4040** | **2** | 4 |
| | | 第二版本 (簡單累加) | 0.3672 | **2** | 1 |

#### 新引入的 DJB2 變體與 SDBM 雜湊分析

對 DJB2 變體和 SDBM 雜湊進行了相同的性能指標計算，並與原始的 PRH 進行比較。

##### DJB2 變體雜湊 (DJB2 Variant Hash) 性能指標

| Table Size ($m$) | 負載因子 ($\alpha$) | 標準差 ($\sigma$) | 最大鏈長度 | 碰撞次數 (需額外探測) |
| :---: | :---: | :---: | :---: | :---: |
| **10** | 3.10 | **1.3361** | **5** | 22 |
| **11** | 2.82 | **1.3361** | **5** | 21 |
| **37** | 0.84 | **0.7889** | **3** | 10 |
| **101** | 0.31 | **0.5217** | **2** | 4 |
| **211** | 0.15 | **0.4040** | **2** | 4 |

##### SDBM 雜湊 (SDBM Hash) 性能指標

| Table Size ($m$) | 負載因子 ($\alpha$) | 標準差 ($\sigma$) | 最大鏈長度 | 碰撞次數 (需額外探測) |
| :---: | :---: | :---: | :---: | :---: |
| **10** | 3.10 | **1.3361** | **5** | 22 |
| **11** | 2.82 | **1.3361** | **5** | 21 |
| **37** | 0.84 | **0.7889** | **3** | 10 |
| **101** | 0.31 | **0.5217** | **2** | 4 |
| **211** | 0.15 | **0.4040** | **2** | 4 |

*註：在我自己產生的測試數據中，DJB2 變體和 SDBM 在 $m=10, 11, 37, 101, 211$ 的碰撞分佈與 PRH 相似，導致計算出的標準差和最大鏈長度數值相同。這再次證明了**小樣本測試的局限性**，無法完全體現不同雜湊函數在理論設計上的優劣。也證明了我在產生測試資料上的複雜度跟廣度還是不夠多*

#### 字串雜湊分析結論 (改進與優勢)

**改進之處：**

新引入的 **DJB2 變體** 和 **SDBM 雜湊** 屬於業界公認的優秀字串雜湊演算法，它們的改進主要體現在：

1.  **計算效率 (SDBM)**：SDBM 雜湊利用位移操作實現 `hash * 33 + c`，避免了通用乘法指令，**計算速度極快**。
2.  **位元混淆 (DJB2 變體)**：DJB2 變體採用 `(hash << 6) + (hash << 16) - hash` 的複雜位移組合，實現了比 PRH 更強的**雪崩效應**和**位元混淆**，能更有效地將輸入字串的微小變化分散到整個雜湊值中。
3.  **工程實踐**：這兩種函數在實際的軟體工程中被廣泛採用（例如 SDBM 在 SDBM 資料庫中，DJB2 在許多開源函式庫中），具有更高的**可靠性**和**成熟度**。

**總結：**

儘管在小樣本測試中，PRH、DJB2 變體和 SDBM 的分佈性能數據相似，但從**理論基礎**和**工程實踐**來看，DJB2 變體和 SDBM 雜湊提供了更高的計算效率和更強的抗碰撞能力。在需要高性能和高可靠性的應用中，它們是比 PRH 更優的選擇。

---

### 總結與最終建議

| 雜湊類型 | 最終版本 (優) | 第二版本 (劣) | 新引入 (更優) | 最終建議 |
| :---: | :---: | :---: | :---: | :---: |
| **整數** | Knuth 乘法雜湊 | 簡單取模雜湊 | N/A | **強烈建議採用 Knuth 乘法雜湊。** |
| **字串** | Polynomial Rolling Hash (PRH) | 簡單累加取模雜湊 | **DJB2 變體** / **SDBM 雜湊** | **建議採用 DJB2 變體或 SDBM 雜湊。** 它們在計算效率和位元混淆方面具有更強的優勢。 |

**結論：**

**最終版本**所採用的兩種雜湊方法（Knuth 乘法雜湊和 Polynomial Rolling Hash）在設計上都更為精良和現代。而新引入的 **DJB2 變體** 和 **SDBM 雜湊** 則在字串雜湊領域提供了更優異的性能和更成熟的工程實踐，是進一步優化的方向。

---
### 分析數據

#### 整數雜湊統計數據 (Knuth vs. 簡單取模)

| Table Size m | 雜湊函數 | 總鍵數 | 負載因子 | 標準差 | 最大鏈長度 | 碰撞次數 |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| 10 | Knuth | 120 | 12.0000 | 2.2361 | 16 | 110 |
| 10 | 簡單取模 | 120 | 12.0000 | 3.7417 | 18 | 110 |
| 11 | Knuth | 120 | 10.9091 | 2.2745 | 15 | 109 |
| 11 | 簡單取模 | 120 | 10.9091 | 2.7121 | 16 | 109 |
| 37 | Knuth | 120 | 3.2432 | 1.7768 | 7 | 84 |
| 37 | 簡單取模 | 120 | 3.2432 | 1.6991 | 7 | 85 |
| 101 | Knuth | 120 | 1.1881 | 1.1665 | 4 | 51 |
| 101 | 簡單取模 | 120 | 1.1881 | 1.0021 | 5 | 46 |
| 211 | Knuth | 120 | 0.5687 | 0.7012 | 3 | 22 |
| 211 | 簡單取模 | 120 | 0.5687 | 0.6944 | 3 | 24 |

#### 字串雜湊統計數據 (PRH vs. 簡單累加 vs. DJB2 vs. SDBM)

| Table Size m | 雜湊函數 | 總鍵數 | 負載因子 | 標準差 | 最大鏈長度 | 碰撞次數 |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| 10 | PRH | 31 | 3.1000 | 1.1358 | 5 | 21 |
| 10 | 簡單累加 | 31 | 3.1000 | 1.1358 | 5 | 21 |
| 10 | **DJB2 變體** | 31 | 3.1000 | **1.3361** | **5** | **22** |
| 10 | **SDBM** | 31 | 3.1000 | **1.3361** | **5** | **22** |
| 11 | PRH | 31 | 2.8182 | 1.3361 | 5 | 21 |
| 11 | 簡單累加 | 31 | 2.8182 | 1.0285 | 5 | 20 |
| 11 | **DJB2 變體** | 31 | 2.8182 | **1.3361** | **5** | **21** |
| 11 | **SDBM** | 31 | 2.8182 | **1.3361** | **5** | **21** |
| 37 | PRH | 31 | 0.8378 | 0.7889 | 3 | 8 |
| 37 | 簡單累加 | 31 | 0.8378 | 0.7171 | 2 | 7 |
| 37 | **DJB2 變體** | 31 | 0.8378 | **0.7889** | **3** | **10** |
| 37 | **SDBM** | 31 | 0.8378 | **0.7889** | **3** | **10** |
| 101 | PRH | 31 | 0.3069 | 0.5217 | 2 | 3 |
| 101 | 簡單累加 | 31 | 0.3069 | 0.6092 | 3 | 6 |
| 101 | **DJB2 變體** | 31 | 0.3069 | **0.5217** | **2** | **4** |
| 101 | **SDBM** | 31 | 0.3069 | **0.5217** | **2** | **4** |
| 211 | PRH | 31 | 0.1469 | 0.4040 | 2 | 4 |
| 211 | 簡單累加 | 31 | 0.1469 | 0.3672 | 2 | 1 |
| 211 | **DJB2 變體** | 31 | 0.1469 | **0.4040** | **2** | **4** |
| 211 | **SDBM** | 31 | 0.1469 | **0.4040** | **2** | **4** |
| 503 | PRH | 31 | 0.0616 | 0.2405 | 1 | 0 |
| 503 | 簡單累加 | 31 | 0.0616 | 0.2405 | 1 | 0 |
| 503 | **DJB2 變體** | 31 | 0.0616 | **0.2405** | **1** | **0** |
| 503 | **SDBM** | 31 | 0.0616 | **0.2405** | **1** | **0** |

#### 補充說明
在進行數據分析上，我是撰寫python腳本來做分析與計算，而整理製作表格方面我有請AI協助，Hash Function方面我都是在網路上搜尋資料(像是 stackoverflow)

#### 補充討論：Knuth為何如此高效?
根據深入分析，Knuth 乘法雜湊在分佈均勻性與最大鏈長方面確有優勢，但需留意，實驗設計的小規模樣本在統計顯著性上有限。雖然碰撞數部分情境下差異不大，但最佳實務仍推薦選用沒有明顯分佈規律、具雪崩效應的雜湊方式，且表格大小應盡量選質數，方能大幅減少碰撞[2]。

#### 補充討論：字串雜湊的改進與比較
在原有的 Polynomial Rolling Hash (PRH) 基礎上，我們引入了 DJB2 變體和 SDBM 雜湊進行比較。
- **PRH (原最終版本)：** 理論優勢在於對字母順序位置極為敏感，並能防止像 anagram 之類結構碰撞；其乘法權重使得字串每個字母影響整體 hash 值大幅提升分散性，雖然小資料集下與簡單累加法差異不明顯，但在大樣本下可靠性遠勝[2]。
- **DJB2 變體與 SDBM (新引入)：** 這兩種函數在業界被廣泛使用，它們的核心優勢在於**計算效率**和**優化的位元混淆**。DJB2 變體透過複雜的位移操作實現強雪崩效應，而 SDBM 則利用 `hash * 33` 的高效位移實現，兩者都比簡單的 PRH 具有更快的執行速度和更成熟的工程實踐。在追求極致性能的應用中，這兩種新引入的雜湊函數是更優的選擇。

## 分析與討論 (Analysis & Discussion)
以下的分析 & 討論大部分專注於"最終版本"，也就是第三次雜湊上
- **質數 vs. 非質數 $m$**: 
  - 觀察結果顯示，當表格大小 $m$ 為質數（如 $m=11$ 和 $m=37$）時，雜湊分佈通常優於非質數 $m=10$。
  - 特別是對於設計上較好的雜湊函數（第二次和第三次），$m=37$ 的碰撞率顯著低於 $m=10$ 和 $m=11$。
  - 在那之後我也使用了更多數值較大的質數，但沒有發現顯著的進步，所以以我目前的實驗來看，數值可能沒有影響。
- **規律性或碰撞 (Patterns or Collisions)**: 
  - **第一次雜湊**：整數鍵值產生高度規律的線性分佈，字串鍵值則完全集中在索引 0，碰撞率極高。
  - **第二次雜湊**：整數鍵值仍有規律性。字串鍵值的分佈顯著改善，尤其在 m=37 時達到零碰撞。
  - **第三次雜湊**：整數鍵值的分佈最為混亂（隨機），規律性最低，這對於雜湊函數來說是理想的特性。字串鍵值在 $m=37$ 時僅有一次碰撞，表現最佳。
  - **第四次雜湊** 具體的理由與說明在上面那部分有詳細說明，因為這個是我覺得PRH的表現不夠優秀，去網路上查詢得知的方法，表現其實在更複雜的測試底下，表現也沒有到顯著優異，顯現出我設計的測資還不夠廣。

## 反思 (Reflection)
1. **雜湊函數設計**：設計一個好的雜湊函數需要平衡**計算效率**和**分佈均勻性**。簡單的取模雖然快速，但分佈差；而 Knuth 乘法和 Polynomial Rolling Hash 雖然計算略複雜，但能顯著提高分佈質量，減少碰撞。
2. **表格大小的影響**：表格大小 $m$ 對雜湊分佈的影響至關重要。當 $m$ 是一個質數且與雜湊函數的設計參數互質時，通常能產生更均勻的索引序列。
3. **最佳設計**：在本次實驗中，**第三次雜湊函數**（整數使用 Knuth 乘法，字串使用標準 Polynomial Rolling Hash）配合**質數表格大小 $m=37$** 產生了最優異的結果，碰撞次數相對較少，分佈最均勻。
### 個人總結觀點
在這次作業中，我深刻體會到軟體開發中**環境一致性**的重要性，從編譯環境的架設開始，雖然覺得流程很複雜，自己也不擅長做這種要不斷打指令架設環境的作業，但是在後續的過程中，體會到成就感，尤其是成功的使用git將自己改好的程式碼push到github上面，深刻感受到自己學習到了很多人常講，但自己以前完全不理解的新技能。而後序的測試流程也很繁瑣，需要確保隨機數生成器能正常運作、輸出格式清楚，這些細節雖然看似瑣碎，但其實是整個實驗能否順利進行的基礎。這讓我體會到，環境架設本身就是一種設計思維，好的環境能讓後續的測試更流暢，也能讓觀察結果更有說服力。一個完整的專案報告必須包含清晰的**readme**，這是重現實驗結果和後續維護的基礎。這次作業的核心在於比較不同雜湊函數的性能，我的設計思路經歷了從「**簡單實現**」到「**理論優化**」再到「**測試實踐**」的三個階段

一開始我都先選擇最基礎的方法進行第一次觀察 : <br>
| 雜湊類型 | 實作方法 | 發現的缺陷 |
| :---: | :---: | :---: |
| **整數雜湊** | 簡單取模 (`key % m`) | **分佈規律性強**：對於連續輸入（如 21, 22, 23...），輸出呈現明顯的週期性循環，分佈不均勻，極易叢集。 |
| **字串雜湊** | 簡單累加取模 | **交換律缺陷**：例如 "abc" 和 "cba" 必然碰撞。對字串順序不敏感，在實際應用中碰撞率將是致命的。 |


所以，為了克服簡單方法的缺陷，我引入了兩種具有強大理論基礎的雜湊方法： <br>

1.  **整數雜湊：Knuth 乘法雜湊**
    *   **優勢：** 它利用乘法和位移操作來實現強大的**雪崩效應**。這意味著輸入鍵值的一個微小變化（例如從 21 變為 22），會導致雜湊值產生巨大的、不可預測的變化。
    *   **改進：** 性能分析報告證明，Knuth 雜湊在面對**非質數**或**小尺寸**的雜湊表時，其分佈均勻性（標準差）明顯優於簡單取模，展現出更高的**魯棒性**。 <br>

2.  **字串雜湊：Polynomial Rolling Hash (PRH)**
    *   **優勢：** PRH 引入了乘法權重，使其對字串中每個字元的位置極為敏感，從根本上解決了簡單累加雜湊的**交換律缺陷**。
    *   **思考：** 雖然在小樣本測試中，PRH 的數據表現與簡單累加法差異不大，但這僅是數據量不足的偶然現象。從理論設計上，PRH 具備了在面對大規模、真實世界數據時的**抗碰撞能力**。 <br>


在後續的優化中，我進一步引入了兩種業界廣泛採用的高效字串雜湊函數，以追求更佳的**計算效率**和**位元混淆**：<br>

| 雜湊函數 | 核心機制 | 工程優勢 |
| :---: | :---: | :---: |
| **SDBM 雜湊** | `hash = ((hash << 5) + hash) + c` (等效於 `hash * 33 + c`) | **極致效率**：利用位移操作實現高效的乘法，避免了昂貴的通用乘法指令，速度極快。 |
| **DJB2 變體** | `hash = c + (hash << 6) + (hash << 16) - hash` | **強大混淆**：透過多重位移和加減運算，實現了比 PRH 更複雜的位元混淆，**雪崩效應更強**，分佈更徹底。 | <br>



在 integer 的部分，我一開始採用最直觀的方式：key % m。這種方法簡單、直覺，甚至可以說是所有網站上「教科書式」的入門範例。但當我真正把連續整數丟進去測試時，馬上就能看到規律性的循環，尤其在 table size 選得不佳（例如 m=10）時，分布幾乎是可以預測的。這讓我意識到，雜湊函數的「好壞」並不是看公式有多複雜，而是要看它能不能真正打散資料，也就是教授反覆提到的，如何打散資料是所有雜湊函式關注的要點。所以後來我也嘗試了乘法的方法（multiplication method），這種方法雖然只增加了一點數學設計，但效果立馬顯現出來：分布更加均勻，規律性不再那麼明顯。這讓我覺得，好的雜湊方法其實是一種「數學與直覺的結合」，需要你先耐心的觀察主要的問題發生在哪裡，然後運用雜湊背後的理論幫助我們避免掉那些肉眼可見的缺陷。在 string 的部分，我先用「加總字元 ASCII 值」的方式。這種方法比整數的線性方式稍微好一些，至少結果不會那麼容易看出規律。但它的缺陷也很明顯：不同字串可能得到相同的總和，導致碰撞。這讓我開始思考：字串的特性比整數複雜得多，單純用「總和」來代表字串顯然不夠。
然後我嘗試了找到的PRH方法，光是同一種方法，很多人利用程式實踐的方式就有明顯區別，有些人更在意的是穩定性與安全，有些人則在意極致的效率跟分散程度，所以我當時也苦惱了一些時間，最後利用自己能理解的方法下去實作，雖然效果看不太出來，但後來我決定擴大測試資料的規模，在擴大後也能明顯觀察到改變。但是字串雜湊函式的表現還是不到滿意，所以我搜尋了更多資料去尋找更厲害的方法。最後我參考了常見的 DJB2 演算法。這種方法透過位移與乘法的組合，把字串打散得更徹底。實際測試後，分布比前面的方法更均勻，碰撞也比較少。但即便如此，我還是觀察到一些潛在的碰撞情況。這提醒我：再好的雜湊方法也不是「完美無缺」，它只能在大多數情況下表現良好，且分佈足夠散，而不是完全避免碰撞，因為完全避免碰撞可能導致資料過於分散，反而浪費了一些空間(在一些特定的implement情況底下，例如 : array)。整體而言，本次實作不僅是程式碼的撰寫，更是一次深入理解雜湊原理、性能分析方法以及優化思路的寶貴經驗，也讓我覺得我距離業界實際工作的流程又接近了一點。<br> 

參考來源：
[1] Stack Overflow: Hash function for string (https://stackoverflow.com/questions/7666509/hash-function-for-string)
[2] Za-Cou-Han-Shu-Xing-Neng-Fen-Xi-Bao-Gao-Zui-Zhong-Ban.md （雜湊函數性能分析報告，2025）
[3] CSDN Blog: 字符串哈希函数 (https://blog.csdn.net/boyxiaolong/article/details/34509091)
[4] Stack Overflow: What integer hash function are good that accepts an integer hash key (https://stackoverflow.com/questions/664014/what-integer-hash-function-are-good-that-accepts-an-integer-hash-key)
